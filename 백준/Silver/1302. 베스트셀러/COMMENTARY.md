### 백준 1302 베스트셀러

**map과 정렬을 이용한 문제**

처음에 이 문제를 보았을 때 map에 책의 제목과 count를 담고 정렬을 하면 되겠구나 생각했는데 count값이 같으면 사전순으로 정렬을 해야 하니 class를 따로 만들어 compareTo를 구현해 정렬할 생각이였다. 하지만 그렇게 되면 이미 map에 count가 있을 경우 복잡해지기 때문에 그냥 map을 이용해야 겠다 생각하고 풀이를 참고했다.

원래 map에 key값이나 value값이 이미 존재하는지를 확인하기 위해 containsKey 메소드 또는 cotainsValue를 사용했는데 getOrDefault라는 메소드를 처음 알았다. 

**getOrDefault** 메소드는 **찾는 키가 존재한다면 찾는 키의 값을 반환하고 없다면 기본 값을 반환하는 메소드** 이다.

| **getOrDefault(**Object key, V DefaultValue**)**             |
| ------------------------------------------------------------ |
| **key**: 값을 가져와야 하는 요소의 키                        |
| **defaultValue**: 지정된 키로 매핑된 값이 없는 경우 반환되어야 하는 디폴트 값 |
| **반환 값**: 찾는 key가 존재한다면 해당 **key에 매핑되어 있는  값**을 반환하고 그렇지 않으면 **디폴트 값**이 반환됨 |

map에 key와 value를 put하면서 가장 많이 팔린 책의 개수를 max에 삽입한다. 그런다음 가장 많이 팔린 책 제목을 담는 리스트를 생성하고 map에서 keySet을 반환하여 max, 즉 가장 많이 팔린 책의 개수와 책 제목에 해당하는 value가 같다면 list에 집어넣는다. 마지막으로 가장 많이 팔린 책 제목 리스트를 오름차순으로 정려해주면 가장 많이 팔린 책들이 사전순으로 정렬되어 첫번째 인덱스의 값을 print해주면 된다.

아무래도 정렬을 이용한 문제이다 보니 keySet또는 value를 담은 리스트를 정렬해야 겠다라는 생각으로만 가득차 있었다. map에 put할 때 부터 count의 최대 값을 구해놓고 value값이 count값과 같다면 리스트를 생성하여 책의 제목을 집어 넣은 뒤 정렬하면 가장 많이 팔린 책이 여러 개일 경우에는 사전 순으로 가장 앞서는 제목을 출력할 수 있구나 깨달았다.


