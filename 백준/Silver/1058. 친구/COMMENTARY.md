### 백준 1058 친구

**플로이드 알고리즘을 이용한 문제**

A와 B가 친구이거나 A와 B사이에 친구 C가 있으면 A와 B도 친구사이다. 처음 문제를 봤을 때 단순한 탐색 문제이겠구나 생각하고  코드를 짜다보니 A와 B가 친구인 점을 잡으면 A와 B사이의 친구 C를 놓치게 되거나 반대의 경우가 생겼다. 고민하다가 알고리즘 자체가 잘못된 것 같아 풀이를 참고했다.

이 문제는 플로이드를 활용한 문제였다. 3중 for문을 통해 **if (A[i][k] + A[k][j] < A[i][j]) A[i][j] = A[i][k] + A[k][j]** 공식을 활용한다. 여기까지는 이해가 됐는데 풀이에서 경로가 2이하인 노드의 개수를 count하는 것이 이해가 되지 않았다. 만약 경로가 3이상이면 A노드와 B노드 사이에 노드가 n-1개가 있다는 것인데 그래프 상에서 이어져 있더라도 A노드와 B노드 사이에 노드가 없거나 노드가 1개인 경우에만 A노드와 B노드는 친구이다.

 A와 B가 직접적인 친구사이일때는 그래프에서 **경로가 1**이 되며 A와 B 사이의 친구 C가 있을 때는 둘 사이의 **경로가 2**가 된다. max는 현재 최대 2-친구 개수이고 count는 i번째 인덱스, 즉 i번째 사람의 2-친구의 개수이다. 그래프에서 경로가 0이 아니고 2 이하이면 count를 증가시켜 max와 비교하여 새로운 max값을 할당한다. 

 풀이를 보니 왜 플로이드 알고리즘을 사용하는지 이해가 되었다. 어떻게 문제만 보고 딱 '플로이드 알고리즘을 활용하는 문제이다!' 라고 생각이 떠오르는지 참 신기하다.. 역시 아직 많이 부족한 것 같다^^..
