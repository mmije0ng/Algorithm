### 백준 2075 n번째 큰 수

**자료 구조, 우선순위 큐, 정렬을 이용한 문제**

n*n의 배열에서 n번째 큰 수를 찾는 프로그램이다. 처음에 생각한 방법은 Arrays.sort()를 이용하여 내림차순으로 배열을 정리한 후, 배열의 n-1번째 요소가 n번째 큰 수이겠구나 생각했다. 이렇게 풀었더니 시간 초과가 나왔다.

 **Arrays.sort()**는 **DualPivotQuicksort **방식으로 두 개의 피봇을 기준으로 퀵정렬을 수행한다. 이 때 시간복잡도는 평균 O(nlogn), 최악 O(n^2)를 갖는다. 이 때문에 시간초과가 난 것 같다. 하지만 Collections 클래스의 **Collections.sort()**는 **TimSort** (삽입정렬과 합병정렬을 결합한 정렬)방식을 사용하여 평균의 경우 O(n), 최악의 경우 O(nlogn)으로 Arrays 클래스의 sort 메소드보다 더 빠르다는 것을 알 수 있다.

문제에서 제시된 배열은 이차원 배열이지만 나는 인덱스 공식 i*n+j를 이용하여 nxn크기의 일차원 배열로 만든 뒤 Collections.sort() 메소드를 호출하였다.

 풀이를 더 찾아보니 시간을 줄이기 위해 우선순위 큐를 이용하여 문제를 해결할 수도 있겠구나 깨달았다. 담는 배열의 크기를 N으로 유지하고 그때마다 최솟값과 현재 들어온 값을 비교해서 더 작은 값을 pop하고 큰 값을 push한다. 최종적으로 가장 큰 원소 n개가 배열에 들어갈 것이며 n번째 큰 수는 해당 배열에서 가장  첫번째 인덱스의 값이 된다.



|       메소드       |   최선   |   평균   |   최악   | 정렬 방식          |
| :----------------: | :------: | :------: | :------: | ------------------ |
|   Arrays.sort()    | O(nlogn) | O(nlogn) |  O(n^2)  | DualPivotQuicksort |
| Collections.sort() |   O(n)   | O(nlogn) | O(nlogn) | Timsort            |

`
